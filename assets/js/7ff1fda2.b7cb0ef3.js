"use strict";(self.webpackChunkgithub_page=self.webpackChunkgithub_page||[]).push([[9922],{8570:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>y});var o=n(79);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=o.createContext({}),c=function(e){var t=o.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return o.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},m=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),m=c(n),y=r,d=m["".concat(s,".").concat(y)]||m[y]||u[y]||a;return n?o.createElement(d,l(l({ref:t},p),{},{components:n})):o.createElement(d,l({ref:t},p))}));function y(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,l=new Array(a);l[0]=m;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,l[1]=i;for(var c=2;c<a;c++)l[c]=n[c];return o.createElement.apply(null,l)}return o.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3226:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>u,frontMatter:()=>a,metadata:()=>i,toc:()=>c});var o=n(9675),r=(n(79),n(8570));const a={slug:"comments",title:"Creating rich comments",authors:["unional"],tags:["comment","documentation","DX"]},l="Comments",i={unversionedId:"guidelines/documentations/comments",id:"guidelines/documentations/comments",title:"Creating rich comments",description:"You should add JSDoc comments to your code.",source:"@site/docs/guidelines/documentations/comments.md",sourceDirName:"guidelines/documentations",slug:"/guidelines/documentations/comments",permalink:"/typescript-blackbook/docs/guidelines/documentations/comments",draft:!1,editUrl:"https://github.com/unional/typescript-guidelines/tree/main/github-page/docs/guidelines/documentations/comments.md",tags:[{label:"comment",permalink:"/typescript-blackbook/docs/tags/comment"},{label:"documentation",permalink:"/typescript-blackbook/docs/tags/documentation"},{label:"DX",permalink:"/typescript-blackbook/docs/tags/dx"}],version:"current",frontMatter:{slug:"comments",title:"Creating rich comments",authors:["unional"],tags:["comment","documentation","DX"]},sidebar:"tutorialSidebar",previous:{title:"Guidelines",permalink:"/typescript-blackbook/docs/guidelines/"},next:{title:"Naming Convention",permalink:"/typescript-blackbook/docs/guidelines/files_and_folders/naming-convention"}},s={},c=[],p={toc:c};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"comments"},"Comments"),(0,r.kt)("p",null,"You ",(0,r.kt)("strong",{parentName:"p"},"should")," add JSDoc comments to your code."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Why?")),(0,r.kt)("p",null,"For a long time, I do not do this.\nMy belief was that the code should be self-explanatory."),(0,r.kt)("p",null,"However, having the comments in the code,\nespecially for public facing code,\nmakes it a lot easier for consumer to use the code."),(0,r.kt)("p",null,"Especially if you can provide examples in the comments."),(0,r.kt)("p",null,"For example, the following is a comment for the ",(0,r.kt)("inlineCode",{parentName:"p"},"IsEqual")," type in ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/unional/type-plus"},"type-plus"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Checks `A` and `B` are equal.\n *\n * ```ts\n * type R = IsEqual<1, 1> // true\n * type R = IsEqual<any, any> // true\n * type R = IsEqual<boolean, boolean> // true\n * type R = IsEqual<true, true> // true\n * type R = IsEqual<[1], [1]> // true\n *\n * type R = IsEqual<boolean, true> // false\n * type R = IsEqual<any, 1> // false\n * type R = IsEqual<[any], [1]> // false\n * type R = IsEqual<{ a: 1 }, { a: 1; b: 2 }> // false\n * ```\n *\n * Note that intersection type checks only works at first level.\n * It cannot be check recursively,\n * or else will run into infinite recursion if the type includes recursive types.\n */\nexport type IsEqual<A, B, Then = true, Else = false> = ...\n")),(0,r.kt)("hr",null),(0,r.kt)("p",null,"You ",(0,r.kt)("strong",{parentName:"p"},"should not")," include import statements in the comment examples."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},"Why?")),(0,r.kt)("p",null,"Your code or type can be reused in different context.\nThe import statement might not be the same in different contexts."),(0,r.kt)("p",null,"For example, your code might be reused in another package.\nSo the import statement will provide the wrong information."),(0,r.kt)("p",null,"\u274c Bad"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Check if the type `T` is exactly `any`.\n *\n * ```ts\n * import type { AnyType } from 'type-plus'\n *\n * type R = AnyType<any> // any\n *\n * type R = AnyType<never> // never\n * type R = AnyType<unknown> // never\n * type R = AnyType<string | boolean> // never\n * ```\n */\nexport type AnyType<T, Then = T, Else = never> = ...\n")),(0,r.kt)("p",null,"\u2705 Good"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-ts"},"/**\n * Check if the type `T` is exactly `any`.\n *\n * ```ts\n * type R = AnyType<any> // any\n *\n * type R = AnyType<never> // never\n * type R = AnyType<unknown> // never\n * type R = AnyType<string | boolean> // never\n * ```\n */\nexport type AnyType<T, Then = T, Else = never> = ...\n")))}u.isMDXComponent=!0}}]);