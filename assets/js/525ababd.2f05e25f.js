"use strict";(self.webpackChunkgithub_page=self.webpackChunkgithub_page||[]).push([[4595],{6650:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"2022-tsc-esm-fix","metadata":{"permalink":"/typescript-blackbook/blog/2022-tsc-esm-fix","editUrl":"https://github.com/unional/typescript-guidelines/tree/main/github-page/blog/2022-06-05-tsc-esm-fix.mdx","source":"@site/blog/2022-06-05-tsc-esm-fix.mdx","title":"Fixing TypeScript code for ESM with `tsc-esm-fix`","description":"TypeScript 4.7 is released \ud83c\udf89!","date":"2022-06-05T00:00:00.000Z","formattedDate":"June 5, 2022","tags":[{"label":"typescript","permalink":"/typescript-blackbook/blog/tags/typescript"},{"label":"ESM","permalink":"/typescript-blackbook/blog/tags/esm"}],"readingTime":2.965,"hasTruncateMarker":false,"authors":[{"name":"Homa Wong (unional)","title":"Clean Architect","url":"https://github.com/unional","imageURL":"https://github.com/unional.png","key":"unional"}],"frontMatter":{"slug":"2022-tsc-esm-fix","title":"Fixing TypeScript code for ESM with `tsc-esm-fix`","authors":["unional"],"tags":["typescript","ESM"]},"nextItem":{"title":"Migrating to ESM","permalink":"/typescript-blackbook/blog/2022-migrate-to-esm"}},"content":"TypeScript 4.7 is released \ud83c\udf89!\\n\\nThe wait is finally over.\\nYou are excited to start your migration.\\n\\nSo you update your `package.json`,\\nupdate your `tsconfig.json`,\\nand voila, you are greeted with a boat load of errors.\\n\\nWhat you need to do is to update your `import` statements:\\n\\n- add `.js` extension for files, or\\n- add `/index.js` for folders.\\n\\nYou can do that manually,\\nor you can use a tool to help you on that.\\n\\nThe tool ([`tsc-esm-fix`]) is the focus of the topic today.\\nBut before that,\\nlet me highlight a few things about the current state of the `type: module` support in TypeScript 4.7,\\nso that you can decide should you take the jump right now,\\nor should you wait a little bit longer.\\n\\nThere are four issues that I\'m aware of related to `type: module`.\\n\\n## The `.js` extension debate\\n\\nThe first one is a debate around the `.js` extension.\\n\\nThe takeaways are:\\n\\n- `.js` is artificial, pointing to a non-existing file\\n- TypeScript team do not want to rewrite JS code\\n- NodeJS needs extra tricks to detect the source type\\n\\nYou can read about the detail here:\\n\\n- <https://github.com/microsoft/TypeScript/issues/49083>\\n- <https://github.com/microsoft/TypeScript/issues/16577#issuecomment-754941937>\\n\\n## broken source map\\n\\nThe second one is that source map is currently broken.\\n\\nIf your code will be used in the browser,\\nyou need to weight that in.\\n\\nYou can read about the detail here: <https://github.com/microsoft/TypeScript/issues/49335>\\n\\n## ts-loader workaround\\n\\nThe third one is that currently [`ts-loader`] does not support ESM module out of the box.\\n\\nYou have to do two things.\\n\\n1. use the `NormalModuleReplacementPlugin`:\\n\\n```js\\n{\\n  plugins: [\\n    new NormalModuleReplacementPlugin(/.js$/, (resource) => {\\n      if (/node_modules/.test(resource.context)) return\\n      resource.request = resource.request.replace(/.js$/, \'\')\\n    })\\n  ]\\n}\\n```\\n\\n2. Do not use `transpileOnly: true`. It does not work.\\n\\nIf I have time, I might dig in to help [`ts-loader`] about this,\\nbut not sure when I\'ll be able to do that.\\n\\nYou can read about the detail here: <https://github.com/TypeStrong/ts-loader/issues/1463>\\n\\n## jest ESM workaround\\n\\nThe last one is an outstanding one,\\nthat [`jest`] does not have native support of ESM.\\n\\nMeaning when you use [`ts-jest`], you also need to use [`babel-jest`] to transpile dependencies within `node_modules`.\\n\\nHere is a nutshell of what you need to do:\\n\\n```js\\n// jest.config.mjs\\nexport default {\\n  preset: \'ts-jest/presets/default-esm\',\\n  globals: {\\n    \'ts-jest\': {\\n      useESM: true\\n    }\\n  },\\n  moduleNameMapper: {\\n    // remove the phantom `.js` extension\\n    \'^(\\\\\\\\.{1,2}/.*)\\\\\\\\.js$\': \'$1\',\\n    // If dependency doing `import ... from \'#<pkg>\'.\\n    // e.g. `chalk` has this: `import ... form \'#ansi-styles\'`\\n    \'#(.*)\': \'<rootDir>/node_modules/$1\'\\n  },\\n  transformIgnorePatterns: [\\n    // Need to MANUALLY identify each ESM package, one by one\\n    \'node_modules/(?!(@unional\\\\\\\\fixture|chalk)/)\'\\n  ],\\n  transform: {\\n    \'^.+\\\\\\\\.(js|jsx|mjs)$\': \'babel-jest\',\\n  }\\n}\\n```\\n\\nYou can find related information here: <https://dev.to/steveruizok/jest-and-esm-cannot-use-import-statement-outside-a-module-4mmj>\\n\\n## `tsc-esm-fix`\\n\\nNow, if you decide to move ahead,\\nthen you can use [`tsc-esm-fix`] to help you.\\n\\nI used it to help me migrating [`type-plus`], which has 140+ files.\\nI\'m using it for other packages as I\'m writing this blog.\\n\\nI have discovered a few bugs and [@antongolub] is very quick to fix them.\\nGo to the repo and give it a star \u2b50!\\n\\nThe easiest way to use it is through `npx` or `yarn dlx`:\\n\\n```sh\\nnpx tsc-esm-fix --src=<src> --ext=\'.js\'\\n\\n# or\\nyarn dlx tsc-esm-fix --src=<src> --ext=\'.js\'\\n```\\n\\nFor [`type-plus`], since I put the source code under the `ts` folder,\\nso the command is:\\n\\n```sh\\nnpx tsc-esm-fix --src=ts --ext=\'.js\'\\n```\\n\\nIf you put your source code under the typical `src` folder,\\nthen the command is:\\n\\n```sh\\nnpx tsc-esm-fix --src=src --ext=\'.js\'\\n```\\n\\nHappy Coding, \ud83e\uddd1\u200d\ud83d\udcbb\\n\\n[@antongolub]: https://github.com/antongolub\\n[`babel-jest`]: https://github.com/facebook/jest#using-babel\\n[`jest`]: http://facebook.github.io/jest/\\n[`ts-jest`]: https://kulshekhar.github.io/ts-jest/\\n[`ts-loader`]: https://github.com/TypeStrong/ts-loader\\n[`tsc-esm-fix`]: https://github.com/antongolub/tsc-esm-fix\\n[`type-plus`]: https://github.com/unional/type-plus"},{"id":"2022-migrate-to-esm","metadata":{"permalink":"/typescript-blackbook/blog/2022-migrate-to-esm","editUrl":"https://github.com/unional/typescript-guidelines/tree/main/github-page/blog/2022-05-17-migrate-to-esm.mdx","source":"@site/blog/2022-05-17-migrate-to-esm.mdx","title":"Migrating to ESM","description":"ESM, or ECMAScript Module, was original part of the ES6/ES2015 specification.","date":"2022-05-17T00:00:00.000Z","formattedDate":"May 17, 2022","tags":[{"label":"typescript","permalink":"/typescript-blackbook/blog/tags/typescript"},{"label":"ESM","permalink":"/typescript-blackbook/blog/tags/esm"}],"readingTime":2.365,"hasTruncateMarker":false,"authors":[{"name":"Homa Wong (unional)","title":"Clean Architect","url":"https://github.com/unional","imageURL":"https://github.com/unional.png","key":"unional"}],"frontMatter":{"slug":"2022-migrate-to-esm","title":"Migrating to ESM","authors":["unional"],"tags":["typescript","ESM"]},"prevItem":{"title":"Fixing TypeScript code for ESM with `tsc-esm-fix`","permalink":"/typescript-blackbook/blog/2022-tsc-esm-fix"},"nextItem":{"title":"@typescript-eslint/eslint-plugin should be a peer dependency","permalink":"/typescript-blackbook/blog/2022-eslint-plugin-peer-deps"}},"content":"ESM, or ECMAScript Module, was original part of the ES6/ES2015 specification.\\nIt turned out to be difficult to implement and was pulled from the core specification at the last minute.\\n\\nThere were many discussions and argument about it.\\nAt one point, it almost falls apart because NodeJS couldn\'t get to a good design to get CommonJS and ESM to co-exist.\\n\\nFast-forward a few years, ESM is mature enough to be used on both NodeJS and browsers.\\n\\nBy now, I\'m pretty sure you have heard of it already.\\n\\nBut for people who write code in TypeScript, while we use `import` and `export` for a very long time,\\nwe were not able to publish the code as ESM.\\n\\nWhat\'s worse is that, some JavaScript code moved on to ESM and the new module package in NodeJS,\\nand TypeScript code cannot consume them.\\n\\nSo the TypeScript code is being left behind.\\n\\nTypeScript 4.5 planned to support the new module system,\\nbut the support was pulled due to some cases were not resolved.\\n\\nWhile it was heartbreaking when the announcement was made,\\nI completely understand and support the rationale behind it.\\n\\nIt would be much worse if the solution is half-baked and released to the world.\\nThe damage it causes could be devastating.\\n\\nTypeScript 4.7 is trying to provide the support again,\\nand hopefully it\'s here to stay.\\n\\n## The big migration\\n\\nSo how to migrate your code to ESM?\\n\\nUpgrade TypeScript:\\n\\n```sh\\nnpm install --dev typescript@rc\\n\\nyarn add -D typescript@rc\\n```\\n\\n(or `typescript` without `@rc` when 4.7 is released).\\n\\nUpdate your `package.json` to:\\n\\n```json\\n{\\n  \\"type\\": \\"module\\",\\n  \\"exports\\": {\\n    \\".\\": {\\n      \\"import\\": {\\n        \\"default\\": \\"<path to main>\\",\\n        \\"types\\": \\"<path to d.ts>\\"\\n      }\\n    }\\n  }\\n}\\n```\\n\\nIn [TypeScript 4.7] announcement and other places mentioned you can provide fallback for CommonJS,\\nbut in general it could cause problems as that will increase the chance of having multiple copies of your library exist in runtime.\\n\\nUpdate your `import` statements to add `.js` extension.\\ne.g.:\\n\\n```ts\\n// import { foo } from \'./foo\'\\nimport { foo } from \'./foo.js\'\\n```\\n\\nUpdate your project files from `.js` to either `.cjs` or `.mjs`.\\n\\nWhen you set the package to use `\\"type\\": \\"module\\"`,\\nYour project files such as `jest.config.js` and `babel.config.js` becomes ambiguous,\\nand you have to update the file extension to reflect if the file is a CommonJS or ESM file.\\n\\nSome tools might not work with the new module format.\\nYou have to disable them for now.\\n\\nTo me, I found that [`size-limit`] does not support it yet.\\n\\nAlso, I found that I can\'t import the default export from TypeScript package transpiled to CommonJS.\\n\\nDon\'t know if that is by design or it is a bug yet.\\n\\nYou can take a look at the [`global-store` PR] as an example.\\n\\nHappy Coding, \ud83e\uddd1\u200d\ud83d\udcbb\\n\\n[`global-store` PR]: https://github.com/unional/global-store/tree/esm\\n[`size-limit`]: https://github.com/ai/size-limit\\n[TypeScript 4.7]: https://devblogs.microsoft.com/typescript/announcing-typescript-4-7-rc/"},{"id":"2022-eslint-plugin-peer-deps","metadata":{"permalink":"/typescript-blackbook/blog/2022-eslint-plugin-peer-deps","editUrl":"https://github.com/unional/typescript-guidelines/tree/main/github-page/blog/2022-05-15-eslint-plugin-peer-deps.mdx","source":"@site/blog/2022-05-15-eslint-plugin-peer-deps.mdx","title":"@typescript-eslint/eslint-plugin should be a peer dependency","description":"Recently I run into this problem:","date":"2022-05-15T00:00:00.000Z","formattedDate":"May 15, 2022","tags":[{"label":"typescript","permalink":"/typescript-blackbook/blog/tags/typescript"},{"label":"eslint","permalink":"/typescript-blackbook/blog/tags/eslint"},{"label":"@typescript-eslint","permalink":"/typescript-blackbook/blog/tags/typescript-eslint"}],"readingTime":0.975,"hasTruncateMarker":false,"authors":[{"name":"Homa Wong (unional)","title":"Clean Architect","url":"https://github.com/unional","imageURL":"https://github.com/unional.png","key":"unional"}],"frontMatter":{"slug":"2022-eslint-plugin-peer-deps","title":"@typescript-eslint/eslint-plugin should be a peer dependency","authors":["unional"],"tags":["typescript","eslint","@typescript-eslint"]},"prevItem":{"title":"Migrating to ESM","permalink":"/typescript-blackbook/blog/2022-migrate-to-esm"},"nextItem":{"title":"TypeScript is ... an abstraction","permalink":"/typescript-blackbook/blog/2022-typescript-is-abstraction"}},"content":"Recently I run into this problem:\\n\\n```sh\\nESLint couldn\'t determine the plugin \\"@typescript-eslint\\" uniquely.\\n\\n- ...\\\\node_modules\\\\@typescript-eslint\\\\eslint-plugin\\\\dist\\\\index.js (loaded in \\".eslintrc.json\\")\\n- ...\\\\node_modules\\\\eslint-config-react-app\\\\node_modules\\\\@typescript-eslint\\\\eslint-plugin\\\\dist\\\\index.js (loaded in \\".eslintrc.json \xbb eslint-config-react-app#overrides[0]\\")\\n```\\n\\nIt is caused by [eslint-config-react-app] using [@typescript-eslint/eslint-plugin] as a `dependency` instead of a `peer dependency`.\\n\\nHere is the [GitHub issue] in [eslint-config-react-app] (also [here][#11828]).\\n\\n## Plugin and dependency\\n\\nThe problem is when one plugin uses another plugin,\\nit should always declare the dependency as a `peer dependency`.\\n\\nThe reason is simple.\\n\\nThe host application (ESLint in this case) controls and loads its plugins.\\nIf the host application is not designed to support loading multiple versions of the same plugin at the same time,\\nwhich most of them don\'t, then the result is an undefined behavior.\\n\\nThat\'s why ESLint plainly detects and disallows it.\\n\\nIt also mentioned it in [its doc].\\n\\nYes, that means the consuming repository needs to add the dependency themselves.\\nAny version incompatibility in the dependency graph would lead to the [doppelg\xe4ngers] problem.\\n\\nThat is an inherited problem of NodeJS resolution algorithm, and is a topic for another day.\\n\\nHappy coding, \ud83e\uddd1\u200d\ud83d\udcbb\\n\\n[@typescript-eslint/eslint-plugin]: https://github.com/typescript-eslint/typescript-eslint/tree/main/packages/eslint-plugin\\n[#11828]: https://github.com/facebook/create-react-app/issues/11828\\n[doppelg\xe4ngers]: https://rushjs.io/pages/advanced/npm_doppelgangers/\\n[eslint-config-react-app]: https://github.com/facebook/create-react-app/tree/main/packages/eslint-config-react-app\\n[GitHub issue]: https://github.com/facebook/create-react-app/issues/12400\\n[its doc]: https://eslint.org/docs/developer-guide/shareable-configs#publishing-a-shareable-config"},{"id":"2022-typescript-is-abstraction","metadata":{"permalink":"/typescript-blackbook/blog/2022-typescript-is-abstraction","editUrl":"https://github.com/unional/typescript-guidelines/tree/main/github-page/blog/2022-05-14-typescript-is-abstraction.mdx","source":"@site/blog/2022-05-14-typescript-is-abstraction.mdx","title":"TypeScript is ... an abstraction","description":"[TypeScript 4.7] is just around the corner.","date":"2022-05-14T00:00:00.000Z","formattedDate":"May 14, 2022","tags":[{"label":"typescript","permalink":"/typescript-blackbook/blog/tags/typescript"}],"readingTime":3.395,"hasTruncateMarker":false,"authors":[{"name":"Homa Wong (unional)","title":"Clean Architect","url":"https://github.com/unional","imageURL":"https://github.com/unional.png","key":"unional"}],"frontMatter":{"slug":"2022-typescript-is-abstraction","title":"TypeScript is ... an abstraction","authors":["unional"],"tags":["typescript"]},"prevItem":{"title":"@typescript-eslint/eslint-plugin should be a peer dependency","permalink":"/typescript-blackbook/blog/2022-eslint-plugin-peer-deps"}},"content":"[TypeScript 4.7] is just around the corner.\\n\\nI feel like it is a good time for me to update this TypeScript guidelines\\nwith what I have learn over the years and how am I using it nowadays.\\n\\nAs you can see,\\nI\'ve reorganized the repository and added this GitHub page\\nto make it easier to share the knowledge.\\n\\nIn these blog posts,\\nI\'m going to share the bits and tips that I learned every day.\\nEventually this information will be incorporated into the guidelines.\\n\\nTo kick things off, I\'m going to talk about what TypeScript is in 2022?\\n\\nNo no, not about the history of TypeScript.\\n\\nIt\'s about how I look at TypeScript and how I use it.\\n\\nIt\'s about when I follow the rules and when I break them.\\n\\n> I know all the rules, and then I know how to break \'em\\n\\n## TypeScript is an abstraction\\n\\nProgramming language is an abstraction.\\n\\nThe abstraction I\'m talking about is not the abstraction of defining an interface or class or inheritance.\\n\\nIt\'s about the code you wrote, the text you typed in the `.ts` or `.tsx` file.\\n\\nIt is an abstraction over the actual binary code executed by the JavaScript engine.\\n\\nA good abstraction emphasizes the important but sometimes has a cost of skipping over some details.\\n\\nFor example, the digital zeros and ones are an abstraction over the analog electrical currents.\\n\\nMost of the time, at least in the sense of modern computing,\\nmissing the details on the different levels of electrical currents is a good thing.\\nAnd we as a programmer don\'t ever need to think about it.\\n\\nBut to the eye of hardware engineer,\\nit is not something they can ignore because there are physical rules they have to follow,\\nand there are actual consequences when putting two wires too close to each other.\\n\\nThe abstraction of programming language is the same.\\nIt is good for most cases, but at some point it will start to breakdown.\\n\\n[rust] is a good example of this.\\nIts ownership model guarantee memory-safety and thread-safety.\\nBut there are rare cases you need to break the rules thus there is a `unsafe` keyword for it.\\n\\nFor [TypeScript], it is not designed to be a 100% sounded language.\\nThat means you will run into those \\"rare\\" cases a lot more often.\\n\\nYou can learn more about soundness [here][note-on-soundness] and [here][example-soundness].\\n\\n## Conclusion\\n\\nSo what should you do? Embrace it.\\n\\nThe `unsafe` keyword in [TypeScript] is `any`.\\nWhile you should avoid using `any` in most cases,\\nit is often enough that your tool chain should not prevent or punish you from using it.\\n\\nYou might think,\\n\\n> \\"hey, I\'m working in a team and I don\'t want my team members who are less familiar with TypeScript to abuse the usage of `any`.\\"\\n\\nYes, that is a legit concern,\\nand you can make your own judgement for your circumstances.\\n\\nMy personal experience is that the number of times I have to break the rules are common enough that making exceptions for the tools (e.g. adding `// eslint ignore` comments) clutter the code and make the code harder to read.\\n\\nMy approach is to rely on unit tests and code reviews to make sure the usage of `any` are in check.\\n\\nAlso, defining the correct type is not always easy and can take significant amount of time.\\nIf you are working under a schedule, you might not have time to do that.\\n\\nAnother point to make is that since [TypeScript] is constantly improving,\\nif you build some complex types, it might work in one version and break in another version.\\n\\nASK ME HOW I KNOW IT.\\n\\nOf course, I\'m not saying allowing your code litters with `any` and call it a day.\\nYou should keep track on those usages and clean it up when you get a chance to.\\n\\nConverting `any` back to a proper type improves efficiency.\\nAs that is why we use [TypeScript].\\n\\nAnd you may discover some bugs along the way.\\n\\n[rust]: https://www.rust-lang.org/\\n[TypeScript]: https://www.typescriptlang.org/\\n[TypeScript 4.7]: https://devblogs.microsoft.com/typescript/announcing-typescript-4-7-rc/\\n[note-on-soundness]: https://www.typescriptlang.org/docs/handbook/type-compatibility.html#a-note-on-soundness\\n[example-soundness]: https://www.typescriptlang.org/play?strictFunctionTypes=false#example/soundness"}]}')}}]);